#requires -version 7.3

#region helper functions
function Set-FileAndFolderSetup {

    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        [Parameter(Mandatory = $true)]
        [string] $FullModuleFolderPath,

        [Parameter(Mandatory = $false)]
        [string] $CurrentLevelFolderPath
    )


    if ([String]::IsNullOrEmpty($CurrentLevelFolderPath)) {
        # First invocation. Handling provider namespace

        $resourceTypeIdentifier = ($FullModuleFolderPath -split '[\/|\\]{1}avm[\/|\\]{1}(res|ptn)[\/|\\]{1}')[2] # avm/res/<provider>/<resourceType>
        $providerNamespace, $resourceType, $childResourceType = $resourceTypeIdentifier -split '[\/|\\]', 3

        $avmModuleRoot = ($FullModuleFolderPath -split $providerNamespace)[0]

        $providerNamespaceFolderPath = Join-Path $avmModuleRoot $providerNamespace
        if (-not (Test-Path $providerNamespaceFolderPath)) {
            if ($PSCmdlet.ShouldProcess("Folder [$providerNamespaceFolderPath]", "Add")) {
                Write-Host "Add folder [$providerNamespaceFolderPath]"
            }
        }

        $resourceTypeFolderPath = Join-Path $avmModuleRoot $providerNamespace $resourceType
        $currentLevelFolderPath = $resourceTypeFolderPath
    }

    # Mandatory file & folders
    if (-not (Test-Path $currentLevelFolderPath)) {
        if ($PSCmdlet.ShouldProcess("Folder [$currentLevelFolderPath]", "Add")) {
            Write-Host "Add folder [$currentLevelFolderPath]"
        }
    }

    $bicepFilePath = Join-Path $CurrentLevelFolderPath 'main.bicep'
    if (-not (Test-Path $bicepFilePath)) {
        if ($PSCmdlet.ShouldProcess("File [$bicepFilePath]", "Add")) {
            Write-Host "Add file [$bicepFilePath]"
        }
    }


    # README can be generated by parent script
    # main.json can be generated by parent script


    # Top-level-only files & folders
    $resourceTypeIdentifier = ($CurrentLevelFolderPath -split '[\/|\\]{1}avm[\/|\\]{1}(res|ptn)[\/|\\]{1}')[2] # avm/res/<provider>/<resourceType>
    $isTopLevel = ($resourceTypeIdentifier -split '[\/|\\]').Count -eq 2

    if ($isTopLevel) {
        $versionFilePath = Join-Path $CurrentLevelFolderPath 'version.json'
        if (-not (Test-Path $versionFilePath)) {
            if ($PSCmdlet.ShouldProcess("File [$versionFilePath]", "Add")) {
                Write-Host "Add file [$versionFilePath]"
            }
        }

        $testFolderPath = Join-Path $CurrentLevelFolderPath 'tests'
        if (-not (Test-Path $testFolderPath)) {
            if ($PSCmdlet.ShouldProcess("Folder [$testFolderPath]", "Add")) {
                Write-Host "Add folder [$testFolderPath]"
            }
        }

        $e2eTestFolderPath = Join-Path $testFolderPath 'e2e'
        if (-not (Test-Path $e2eTestFolderPath)) {
            if ($PSCmdlet.ShouldProcess("Folder [$e2eTestFolderPath]", "Add")) {
                Write-Host "Add folder [$e2eTestFolderPath]"
            }
        }

        $defaultTestFolderPath = Join-Path $e2eTestFolderPath 'default'
        if (-not (Test-Path $defaultTestFolderPath)) {
            if ($PSCmdlet.ShouldProcess("Folder [$defaultTestFolderPath]", "Add")) {
                Write-Host "Add folder [$defaultTestFolderPath]"
            }
        }

        $defaultTestFilePath = Join-Path $defaultTestFolderPath 'main.test.bicep'
        if (-not (Test-Path $defaultTestFilePath)) {
            if ($PSCmdlet.ShouldProcess("file [$defaultTestFilePath]", "Add")) {
                Write-Host "Add file [$defaultTestFilePath]"
            }
        }

        $wafTestFolderPath = Join-Path $e2eTestFolderPath 'waf-aligned'
        if (-not (Test-Path $wafTestFolderPath)) {
            if ($PSCmdlet.ShouldProcess("Folder [$wafTestFolderPath]", "Add")) {
                Write-Host "Add folder [$wafTestFolderPath]"
            }
        }

        $wafTestFilePath = Join-Path $wafTestFolderPath 'main.test.bicep'
        if (-not (Test-Path $wafTestFilePath)) {
            if ($PSCmdlet.ShouldProcess("file [$wafTestFilePath]", "Add")) {
                Write-Host "Add file [$wafTestFilePath]"
            }
        }
    }

    # Check if there are nested modules to handle
    if ($CurrentLevelFolderPath -ne $FullModuleFolderPath) {
        # More children to handle
        $nextChild = ($FullModuleFolderPath -replace ('{0}[\/|\\]*' -f [Regex]::Escape($CurrentLevelFolderPath)) -split '[\/|\\]')[0]
        Set-FileAndFolderSetup -FullModuleFolderPath $FullModuleFolderPath -CurrentLevelFolderPath (Join-Path $CurrentLevelFolderPath $nextChild)
    }
}
Set-FileAndFolderSetup -FullModuleFolderPath 'C:\dev\ip\Azure-bicep-registry-modules\eriqua-fork\avm\res\storage\storage-account\blob-service\container'
#endregion

<#
.SYNOPSIS
Create/update all content of an AVM module that can be generated for the user

.DESCRIPTION
Create/update all content of an AVM module that can be generated for the user
This includes
- The `main.json` template(s)
- The `README.md` file(s)

.PARAMETER ModuleFolderPath
Mandatory. The path to the module folder to generate the content for.

.PARAMETER Recurse
Optional. Set this parameter if you not only want to generate the content for one module, but also any nested module in the same path.

.PARAMETER SkipBuild
Optional. Set this parameter if you don't want to build/compile the JSON template(s) for the contained `main.bicep` file(s).

.PARAMETER SkipReadMe
Optional. Set this parameter if you don't want to generate the ReadMe file(s) for the module(s).

.PARAMETER ThrottleLimit
Optional. The number of parallel threads to use for the generation. Defaults to 5.

.PARAMETER ReadMeScriptFilePath
Optional. The absolute path to the `Set-ModuleReadMe` script. Relevant only if `SkipReadMe` is not set and defaults to the default path of the script in the repository.

.EXAMPLE
Set-AVMModule -ModuleFolderPath 'C:\avm\res\key-vault\vault'

For the [key-vault\vault] module, build the Bicep module template & generate its ReadMe.

.EXAMPLE
Set-AVMModule -ModuleFolderPath 'C:\avm\res\key-vault\vault' -Recurse

For the [key-vault\vault] module or any of its children, build the Bicep module template & generate the ReadMe.

.EXAMPLE
Set-AVMModule -ModuleFolderPath 'C:\avm\res\key-vault\vault' -Recurse -SkipReadMe

For the [key-vault\vault] module or any of its children, build only the Bicep module template.
#>
function Set-AVMModule {

    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        [Parameter(Mandatory = $true)]
        [string] $ModuleFolderPath,

        [Parameter(Mandatory = $false)]
        [switch] $Recurse,

        [Parameter(Mandatory = $false)]
        [switch] $SkipBuild,

        [Parameter(Mandatory = $false)]
        [switch] $SkipReadMe,

        [Parameter(Mandatory = $false)]
        [int] $ThrottleLimit = 5,

        [Parameter(Mandatory = $false)]
        [string] $ReadMeScriptFilePath = (Join-Path (Get-Item $PSScriptRoot).Parent.FullName 'pipelines' 'sharedScripts' 'Set-ModuleReadMe.ps1')
    )

    if ($Recurse) {
        $relevantTemplatePaths = (Get-ChildItem -Path $ModuleFolderPath -Recurse -File -Filter 'main.bicep').FullName
    }
    else {
        $relevantTemplatePaths = Join-Path $ModuleFolderPath 'main.bicep'
    }

    # Building object with all information we need inside of the context of a thread
    $threadObjects = @() + ($relevantTemplatePaths | ForEach-Object {
            @{
                path          = $_
                scriptsToLoad = @(
                    $ReadMeScriptFilePath
                )
                SkipBuild     = $SkipBuild
                SkipReadMe    = $SkipReadMe
            }
        })

    # Using threading to speed up the process
    if ($PSCmdlet.ShouldProcess(('Building & generation of [{0}] modules in path [{1}]' -f $threadObjects.Count, $ModuleFolderPath), "Execute")) {
        $threadObjects | ForEach-Object -ThrottleLimit $ThrottleLimit -Parallel {
            $resourceTypeIdentifier = 'avm-{0}' -f ($_.path -split '[\/|\\]{1}avm[\/|\\]{1}(res|ptn)[\/|\\]{1}')[2] # avm/res/<provider>/<resourceType>

            foreach ($scriptPath in $_.scriptsToLoad) {
                . $scriptPath
            }

            ###############
            ##   Build   ##
            ###############
            if (-not $_.SkipBuild) {
                Write-Output "Building [$resourceTypeIdentifier]"
                bicep build $_.path
            }

            ################
            ##   ReadMe   ##
            ################
            if (-not $_.SkipReadMe) {
                Write-Output "Generating readme for [$resourceTypeIdentifier]"

                # If the template was just build, we can pass the JSON into the readme script to be more efficient
                $readmeTemplateFilePath = (-not $_.SkipBuild) ? (Join-Path (Split-Path $_.path -Parent) 'main.json') : ($_.path)

                Set-ModuleReadMe -TemplateFilePath $readmeTemplateFilePath
            }
        }
    }
}
