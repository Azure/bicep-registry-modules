name: '.Platform: PSRule validation for all defaults and waf-aligned tests'

on:
  push:
    branches:
      - feat/psrule-them-all
    paths:
      - ".github/workflows/avm.platform.check.psrule.yml"
  workflow_dispatch:
    inputs:
      targetPath:
        type: string
        description: "Specify target input path for PSRule analysis (example: avm/res/api-management/service/)"
        required: false
        default: "avm/res/api-management/service/"
      psruleBaseline:
        type: choice
        description: "Select the PSRule baseline to perform PSRule analysis (example: avm/res/api-management/service/)"
        required: true
        default: 'Azure.Default'
        options:
          - Azure.Default
          - Azure.Pillar.Reliability
          - Azure.Pillar.Security
  schedule:
    - cron: '0 12 * * 0' # Weekly Sunday Analysis

env:
    # targetPath: "avm/res/api-management/service/tests/e2e/waf-aligned/main.test.bicep"
    targetPath: "${{ github.event.inputs.targetPath }}"
    psruleBaseline: "${{ github.event.inputs.psruleBaseline }}"
    PSRuleOutputFilePath: "${{ github.event.inputs.targetPath }}PSRule-output.csv"
    PSRuleInputFilePath: "${{ github.event.inputs.targetPath }}PSRule-output.md"
    psRuleFilterRegex: "(defaults|waf-aligned)" # The regex used to filter PSRule compliant files
    psrulePath: "avm/utilities/pipelines/staticValidation/psrule"
    skipPassedRulesReport: $true
    ARM_SUBSCRIPTION_ID: "${{ secrets.ARM_SUBSCRIPTION_ID }}"
    ARM_MGMTGROUP_ID: "${{ secrets.ARM_MGMTGROUP_ID }}"
    ARM_TENANT_ID: "${{ secrets.ARM_TENANT_ID }}"
    TOKEN_NAMEPREFIX: "${{ secrets.TOKEN_NAMEPREFIX }}"

jobs:
  psrule:
    # Analyze module library with PSRule
    name: 'PSRule validation'
    runs-on: ubuntu-latest
    steps:
      # [Init] task(s)
      # ---------------------------
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set environment
        uses: ./.github/actions/templates/avm-setEnvironment
      # [Token replacement] task(s)
      # ---------------------------
      - name: "Replace tokens in relevant file"
        uses: azure/powershell@v1
        with:
          azPSVersion: "latest"
          inlineScript: |
            # Grouping task logs
            Write-Output '::group::Replace tokens in relevant file'

            # Load used functions
            . (Join-Path $env:GITHUB_WORKSPACE 'avm' 'utilities' 'pipelines' 'sharedScripts' 'tokenReplacement' 'Convert-TokensInFileList.ps1')
            . (Join-Path $env:GITHUB_WORKSPACE 'avm' 'utilities' 'pipelines' 'sharedScripts' 'Get-LocallyReferencedFileList.ps1')

            $targetPath = Join-Path $env:GITHUB_WORKSPACE '${{ env.targetPath }}'
            $psRuleFilterRegex = '${{ env.psRuleFilterRegex }}'

            Write-Verbose ('targetPath [{0}]' -f $targetPath) -Verbose

            # Get target files
            if (Test-Path -Path $targetPath -PathType Leaf){
              # Add the template file
              $targetFileList = @(
                $targetPath
              )
              # Add all module template files as they may contain tokens
              $targetFileList += (Get-LocallyReferencedFileList -FilePath $targetPath)
            } else {
              $targetFileList = @()
              # Retrieve all relevant test files in targetPath
              $allTestFiles = (Get-ChildItem -Path $targetPath -Recurse -Filter 'main.test.bicep').FullName | Sort-Object
              $relevantTestFiles = $allTestFiles | Where-Object { $_ -match $psRuleFilterRegex }
              # Add all relevant test files and related module template files as they may contain tokens
              foreach ($relevantTestFile in $relevantTestFiles) {
                $targetFileList += $relevantTestFile
                $targetFileList += (Get-LocallyReferencedFileList -FilePath $relevantTestFile)
              }
            }

            $targetFileList = $targetFileList | Sort-Object -Unique

            # Construct Token Function Input
            $ConvertTokensInputs = @{
              FilePathList = $targetFileList
              Tokens       = @{}
            }

            # Add enforced tokens
            $ConvertTokensInputs.Tokens += @{
              subscriptionId    = '${{ env.ARM_SUBSCRIPTION_ID }}'
              managementGroupId = '${{ env.ARM_MGMTGROUP_ID }}'
            }

            # Add local (source control) tokens
            $tokenMap = @{}
            foreach ($token in (Get-ChildItem env: | Where-Object -Property Name -Like "localToken_*")) {
              $tokenMap += @{ $token.Name.Replace('localToken_','','OrdinalIgnoreCase') = $token.value }
            }
            Write-Verbose ('Using local tokens [{0}]' -f ($tokenMap.Keys -join ', ')) -Verbose
            $ConvertTokensInputs.Tokens += $tokenMap

            # Swap 'namePrefix' token if empty and provided as a GitHub secret
            if([String]::IsNullOrEmpty($ConvertTokensInputs.Tokens['namePrefix'])){
              Write-Verbose 'Using [namePrefix] token from GitHub' -Verbose
              $ConvertTokensInputs.Tokens['namePrefix'] = '${{ env.TOKEN_NAMEPREFIX }}'
            }

            Write-Verbose "Convert Tokens Input:`n $($ConvertTokensInputs | ConvertTo-Json -Depth 10)" -Verbose

            # Invoke Token Replacement Functionality [For Module]
            $null = Convert-TokensInFileList @ConvertTokensInputs

            Write-Output '::endgroup::'
      # [PSRule validation] task(s)
      #-----------------------------
      - name: Run PSRule analysis
        uses: microsoft/ps-rule@v2.9.0
        with:
          modules: "PSRule.Rules.Azure"
          baseline: "${{ env.psruleBaseline }}"
          inputPath: "${{ env.targetPath }}"
          outputFormat: Csv
          outputPath: "${{ env.PSRuleOutputFilePath }}"
          option: "${{ github.workspace }}/${{ env.psrulePath}}/ps-rule.yaml" # Path to PSRule configuration options file
          source: "${{ env.psrulePath}}/.ps-rule/" # Path to folder containing suppression rules to use for analysis.
          summary: false # Disabling as taken care in customized task

      - name: "Parse CSV content"
        if: always()
        uses: azure/powershell@v1
        with:
          azPSVersion: "latest"
          inlineScript: |
            # Grouping task logs
            Write-Output '::group::Parse CSV content'

            # Load used functions
            . (Join-Path $env:GITHUB_WORKSPACE 'avm' 'utilities' 'pipelines' 'staticValidation' 'psrule' 'Set-PSRuleGitHubOutput.ps1')

            # Populate parameter input
            $ParameterInput = @{
              inputFilePath         = '${{ env.PSRuleOutputFilePath }}'
              outputFilePath        = '${{ env.PSRuleInputFilePath }}'
              skipPassedRulesReport = ${{ env.skipPassedRulesReport }}
            }

            Write-Verbose ('Set PS Rule Output with following parameters:`n{0}' -f (ConvertTo-Json $ParameterInput -Depth 10)) -Verbose

            # Invoke Set PSRule Output Functionality
            $null = Set-PSRuleGitHubOutput @ParameterInput

            Write-Output '::endgroup::'

      - name: "Output to GitHub job summaries"
        if: always()
        shell: pwsh
        run: |
          # Grouping task logs
          Write-Output '::group::Output to GitHub job summaries'

          $mdPSRuleOutputFilePath = Join-Path $env:GITHUB_WORKSPACE '${{ env.PSRuleInputFilePath }}'

          if (-not (Test-Path $mdPSRuleOutputFilePath)) {
            Write-Warning ('Input file [{0}] not found. Please check if the previous task threw an error and try again.' -f $mdPSRuleOutputFilePath)
            return ''
          } else {
            Get-Content $mdPSRuleOutputFilePath >> $env:GITHUB_STEP_SUMMARY
            Write-Verbose ('Successfully printed out file [{0}] to Job Summaries' -f $mdPSRuleOutputFilePath) -Verbose
          }

          Write-Output '::endgroup::'

