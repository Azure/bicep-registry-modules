{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "languageVersion": "1.10-experimental",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "_EXPERIMENTAL_WARNING": "Symbolic name support in ARM is experimental, and should be enabled for testing purposes only. Do not enable this setting for any production usage, or you may be unexpectedly broken at any time!",
    "_generator": {
      "name": "bicep",
      "version": "0.19.5.34762",
      "templateHash": "11119322536328847528"
    },
    "name": "Azure Cache for Redis",
    "description": "This module deploys Azure Cache for Redis(Microsoft.Cache/redis) and optionally available integrations.",
    "owner": "sumit-salunke"
  },
  "definitions": {
    "redisConfigurationType": {
      "type": "object",
      "properties": {
        "authNotRequired": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "  If set to true, Redis will not require AUTH to connect.\n  NOTE: authNotRequired can only be set to false if a subnet_id is specified;\n  and only works if there aren't existing instances within the subnet with enable_authentication set to true.\n  "
          }
        },
        "maxmemory-delta": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "  The maximum memory a Redis instance can use, specified as a percentage of total available memory. Valid values range from 0 to 100.\n  Defaults depend on SKU; Basic is 2, Standard is 50, Premium is 200.\n  "
          }
        },
        "maxmemory-policy": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "  How Redis will select what to remove when maxmemory is reached.\n  Default is volatile-lru. Available policies are volatile-lru, allkeys-lru, volatile-random, allkeys-random, volatile-ttl, noeviction.\n  "
          }
        },
        "maxmemory-reserved": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "  Value in megabytes reserved for non-cache usage e.g. failover.\n  Defaults depend on SKU; Basic is 2, Standard is 50, Premium is 200.\n  "
          }
        },
        "maxfragmentationmemory-reserved": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "  Value in megabytes reserved to accommodate for memory fragmentation.\n  Defaults depend on SKU; Basic is 2, Standard is 50, Premium is 200.\n  "
          }
        },
        "rdb-backup-enabled": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "Only available when using the Premium SKU. Is Backup Enabled? Default to false."
          }
        },
        "rdb-backup-frequency": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "  Optional but required when rdbBackupEnabled is true\n  The Backup Frequency in Minutes.\n  Possible values are: 15, 30, 60, 360, 720 and 1440.\n  "
          }
        },
        "rdb-backup-max-snapshot-count": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "  (Optional but required when rdbBackupEnabled is true)\n  The maximum number of snapshots to create as a backup.\n  "
          }
        },
        "rdb-storage-connection-string": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "  (Optional but required when rdbBackupEnabled is true)\n  The Connection String to the Storage Account.  In the format: DefaultEndpointsProtocol=https;BlobEndpoint=my_primary_blob_endpoint;AccountName=my_sa_name;AccountKey=my_primary_access_key.\n  The maximum number of snapshots to retain on disk.\n  "
          }
        }
      }
    },
    "redisPatchScheduleType": {
      "type": "object",
      "properties": {
        "dayOfWeek": {
          "type": "string",
          "metadata": {
            "description": "The day of the week when a cache can be patched. Possible values are Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday."
          }
        },
        "startHourUtc": {
          "type": "int",
          "metadata": {
            "description": "The start hour after which cache patching can start."
          }
        },
        "maintenanceWindow": {
          "type": "int",
          "nullable": true,
          "metadata": {
            "description": "ISO8601 timespan specifying how much time cache patching can take."
          }
        }
      }
    },
    "diagnosticSettingsRetentionPolicyType": {
      "type": "object",
      "properties": {
        "days": {
          "type": "int",
          "metadata": {
            "description": "the number of days for the retention in days. A value of 0 will retain the events indefinitely."
          }
        },
        "enabled": {
          "type": "bool",
          "metadata": {
            "description": "a value indicating whether the retention policy is enabled."
          }
        }
      },
      "metadata": {
        "description": "The retention policy for this log or metric."
      }
    },
    "diagnosticSettingsLogsType": {
      "type": "object",
      "properties": {
        "category": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "Name of a Diagnostic Log category for a resource type this setting is applied to. e.g. 'ConnectedClientList'"
          }
        },
        "categoryGroup": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "Create firewall rule before the virtual network has vnet service endpoint enabled."
          }
        },
        "enabled": {
          "type": "bool",
          "metadata": {
            "description": "A value indicating whether this log is enabled."
          }
        },
        "retentionPolicy": {
          "$ref": "#/definitions/diagnosticSettingsRetentionPolicyType",
          "nullable": true
        }
      },
      "metadata": {
        "description": "The list of log settings."
      }
    },
    "diagnosticSettingsMetricsType": {
      "type": "object",
      "properties": {
        "category": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "Name of a Diagnostic Metric category for a resource type this setting is applied to. 'AllMetrics'"
          }
        },
        "enabled": {
          "type": "bool",
          "metadata": {
            "description": "A value indicating whether this metric is enabled."
          }
        },
        "retentionPolicy": {
          "$ref": "#/definitions/diagnosticSettingsRetentionPolicyType",
          "nullable": true
        },
        "timeGrain": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "the timegrain of the metric in ISO8601 format."
          }
        }
      },
      "metadata": {
        "description": "The list of metric settings."
      }
    },
    "diagnosticSettingsEventHubType": {
      "type": "object",
      "properties": {
        "eventHubAuthorizationRuleId": {
          "type": "string",
          "metadata": {
            "description": "The resource Id for the event hub authorization rule."
          }
        },
        "eventHubName": {
          "type": "string",
          "metadata": {
            "description": "The name of the event hub."
          }
        }
      },
      "metadata": {
        "description": "The settings required to use EventHub."
      }
    },
    "diagnosticSettingsReceiversType": {
      "type": "object",
      "properties": {
        "eventHub": {
          "$ref": "#/definitions/diagnosticSettingsEventHubType",
          "nullable": true
        },
        "logAnalyticsDestinationType": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "A string indicating whether the export to Log Analytics should use the default destination type, i.e. AzureDiagnostics, or a target type created as follows: {normalized service identity}_{normalized category name}."
          }
        },
        "marketplacePartnerId": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "The full ARM resource ID of the Marketplace resource to which you would like to send Diagnostic Logs."
          }
        },
        "storageAccountId": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "The resource ID of the storage account to which you would like to send Diagnostic Logs."
          }
        },
        "workspaceId": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "The full ARM resource ID of the Log Analytics workspace to which you would like to send Diagnostic Logs."
          }
        }
      },
      "metadata": {
        "description": "Destiantion options."
      }
    },
    "diagnosticSettingsPropertiesType": {
      "type": "object",
      "properties": {
        "logs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/diagnosticSettingsLogsType"
          },
          "nullable": true
        },
        "metrics": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/diagnosticSettingsMetricsType"
          },
          "nullable": true
        },
        "serviceBusRuleId": {
          "type": "string",
          "nullable": true,
          "metadata": {
            "description": "The service bus rule Id of the diagnostic setting. This is here to maintain backwards compatibility."
          }
        },
        "diagnosticReceivers": {
          "$ref": "#/definitions/diagnosticSettingsReceiversType",
          "nullable": true
        }
      }
    },
    "firewallRulesType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "metadata": {
            "description": "The resource name."
          },
          "maxLength": 128,
          "minLength": 1
        },
        "startIpAddress": {
          "type": "string",
          "metadata": {
            "description": "The start IP address of the server firewall rule. Must be IPv4 format."
          }
        },
        "endIpAddress": {
          "type": "string",
          "metadata": {
            "description": "The end IP address of the server firewall rule. Must be IPv4 format."
          }
        }
      }
    }
  },
  "parameters": {
    "prefix": {
      "type": "string",
      "defaultValue": "redis-",
      "metadata": {
        "description": "Optional. The prefix of the Redis cache resource name."
      }
    },
    "name": {
      "type": "string",
      "defaultValue": "[take(format('{0}{1}', parameters('prefix'), uniqueString(resourceGroup().id, parameters('location'))), 44)]",
      "metadata": {
        "description": "Optional. The name of the Redis cache resource."
      }
    },
    "serverName": {
      "type": "string",
      "defaultValue": "[parameters('name')]",
      "metadata": {
        "description": "Optional. Override the name of the server."
      }
    },
    "location": {
      "type": "string",
      "metadata": {
        "description": "Required. The location to deploy the Redis cache service."
      }
    },
    "tags": {
      "type": "object",
      "defaultValue": {},
      "metadata": {
        "description": "Optional. Tags of the resource."
      }
    },
    "skuName": {
      "type": "string",
      "defaultValue": "Basic",
      "metadata": {
        "description": "Optional. The type of Redis cache to deploy."
      },
      "allowedValues": [
        "Basic",
        "Premium",
        "Standard"
      ]
    },
    "enableNonSslPort": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Specifies whether the non-ssl Redis server port (6379) is enabled."
      }
    },
    "minimumTlsVersion": {
      "type": "string",
      "defaultValue": "1.2",
      "metadata": {
        "description": "Optional. Requires clients to use a specified TLS version (or higher) to connect."
      },
      "allowedValues": [
        "1.0",
        "1.1",
        "1.2"
      ]
    },
    "publicNetworkAccess": {
      "type": "string",
      "defaultValue": "",
      "allowedValues": [
        "",
        "Enabled",
        "Disabled"
      ],
      "metadata": {
        "description": "Optional. Whether or not public network access is allowed for this resource."
      }
    },
    "redisConfiguration": {
      "$ref": "#/definitions/redisConfigurationType",
      "defaultValue": {},
      "metadata": {
        "description": "Optional. All Redis Settings."
      }
    },
    "redisVersion": {
      "type": "string",
      "defaultValue": "6.0",
      "metadata": {
        "description": "Optional. Redis version. Only major version will be used in PUT/PATCH request with current valid values: (4, 6)."
      },
      "allowedValues": [
        "4.0",
        "6.0"
      ]
    },
    "capacity": {
      "type": "int",
      "defaultValue": 1,
      "metadata": {
        "description": "Optional. The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4)."
      },
      "allowedValues": [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ]
    },
    "shardCount": {
      "type": "int",
      "defaultValue": 1,
      "metadata": {
        "description": "Optional. The number of shards to be created on a Premium Cluster Cache. Set 0 to disable this feature."
      }
    },
    "replicasPerMaster": {
      "type": "int",
      "defaultValue": 1,
      "metadata": {
        "description": "Optional. Amount of replicas to create per master for this Redis Cache."
      },
      "minValue": 1
    },
    "replicasPerPrimary": {
      "type": "int",
      "defaultValue": 1,
      "metadata": {
        "description": "Optional. Amount of replicas to create per primary for this Redis Cache."
      },
      "minValue": 1
    },
    "staticIP": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Static IP address. Optionally, may be specified when deploying a Redis cache inside an existing Azure Virtual Network; auto assigned by default."
      }
    },
    "subnetId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1."
      }
    },
    "tenantSettings": {
      "type": "object",
      "defaultValue": {},
      "metadata": {
        "description": "Optional. A dictionary of tenant settings."
      }
    },
    "zoneRedundancyEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Should Zone Redundancy be enabled for this Redis Cache? The target Region must support availability zones, therefore even if this is set true, it will only activate zone redudancy in a supported region. Set this false to disable zone redundancy completely, regardless if a region supports availability zones."
      }
    },
    "numberOfZones": {
      "type": "int",
      "defaultValue": 3,
      "metadata": {
        "description": "The number of logical zones to enable for the Redis Cache. The default is 3. The number must be a positive integer from 1 to 3. Use 1 for single-zoned resources. For multi-zoned resources, the value must be less than or equal to the number of supported zones."
      }
    },
    "zoneOffset": {
      "type": "int",
      "defaultValue": 0,
      "metadata": {
        "description": "The offset from the starting logical availability zone. An error will be returned if zoneOffset plus numberOfZones exceeds the number of supported zones in the target Region."
      }
    },
    "roleAssignments": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Array of role assignment objects that contain the 'roleDefinitionIdOrName' and 'principalId' to define RBAC role assignments on this resource. In the roleDefinitionIdOrName attribute, you can provide either the display name of the role definition, or its fully qualified ID"
      }
    },
    "firewallRules": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/firewallRulesType"
      },
      "defaultValue": [],
      "metadata": {
        "description": "Optional. List of firewall rules to create on server."
      }
    },
    "privateEndpoints": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Define Private Endpoints that should be created for Azure Redis Cache."
      }
    },
    "privateEndpointsApprovalEnabled": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Toggle if Private Endpoints manual approval for Azure Redis Cache should be enabled."
      }
    },
    "redisPatchSchedule": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/redisPatchScheduleType"
      },
      "defaultValue": [],
      "metadata": {
        "description": "The predefined schedule for patching redis server. The Patch Window lasts for 5 hours from the start_hour_utc.\nIf schedule is not specified, the update can happen at any time. See https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-administration#schedule-updates-faq\n"
      }
    },
    "diagnosticSettingsProperties": {
      "$ref": "#/definitions/diagnosticSettingsPropertiesType",
      "defaultValue": {},
      "metadata": {
        "description": "Provide mysql diagnostic settings properties."
      }
    }
  },
  "variables": {
    "copy": [
      {
        "name": "varPrivateEndpoints",
        "count": "[length(parameters('privateEndpoints'))]",
        "input": {
          "name": "[format('{0}-{1}', parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].name, parameters('serverName'))]",
          "privateLinkServiceId": "[resourceId('Microsoft.Cache/redis', parameters('serverName'))]",
          "groupIds": [
            "redisCache"
          ],
          "subnetId": "[parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].subnetId]",
          "privateDnsZones": "[if(contains(parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')], 'privateDnsZoneId'), createArray(createObject('name', 'default', 'zoneId', parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].privateDnsZoneId)), createArray())]"
        }
      }
    ],
    "enableMysqlDiagnosticSettings": "[if(and(and(and(empty(tryGet(tryGet(parameters('diagnosticSettingsProperties'), 'diagnosticReceivers'), 'workspaceId')), empty(tryGet(tryGet(parameters('diagnosticSettingsProperties'), 'diagnosticReceivers'), 'eventHub'))), empty(tryGet(tryGet(parameters('diagnosticSettingsProperties'), 'diagnosticReceivers'), 'storageAccountId'))), empty(tryGet(tryGet(parameters('diagnosticSettingsProperties'), 'diagnosticReceivers'), 'marketplacePartnerId'))), false(), true())]",
    "isPremium": "[equals(parameters('skuName'), 'Premium')]",
    "isZoneRedundant": "[and(variables('isPremium'), parameters('zoneRedundancyEnabled'))]",
    "varZones": "[if(variables('isZoneRedundant'), pickZones('Microsoft.Cache', 'redis', parameters('location'), parameters('numberOfZones'), parameters('zoneOffset')), createArray())]"
  },
  "resources": {
    "redisCache": {
      "type": "Microsoft.Cache/redis",
      "apiVersion": "2022-06-01",
      "name": "[parameters('serverName')]",
      "location": "[parameters('location')]",
      "tags": "[parameters('tags')]",
      "properties": {
        "enableNonSslPort": "[parameters('enableNonSslPort')]",
        "minimumTlsVersion": "[parameters('minimumTlsVersion')]",
        "publicNetworkAccess": "[if(not(empty(parameters('publicNetworkAccess'))), parameters('publicNetworkAccess'), if(not(empty(parameters('publicNetworkAccess'))), 'Disabled', null()))]",
        "redisConfiguration": "[if(not(empty(parameters('redisConfiguration'))), parameters('redisConfiguration'), null())]",
        "redisVersion": "[parameters('redisVersion')]",
        "shardCount": "[if(and(variables('isPremium'), greaterOrEquals(parameters('shardCount'), 1)), parameters('shardCount'), null())]",
        "replicasPerMaster": "[if(variables('isPremium'), parameters('replicasPerMaster'), null())]",
        "replicasPerPrimary": "[if(variables('isPremium'), parameters('replicasPerPrimary'), null())]",
        "sku": {
          "capacity": "[parameters('capacity')]",
          "family": "[if(variables('isPremium'), 'P', 'C')]",
          "name": "[parameters('skuName')]"
        },
        "staticIP": "[if(not(empty(parameters('staticIP'))), parameters('staticIP'), null())]",
        "subnetId": "[if(not(empty(parameters('subnetId'))), parameters('subnetId'), null())]",
        "tenantSettings": "[parameters('tenantSettings')]"
      },
      "zones": "[if(greater(length(variables('varZones')), 0), variables('varZones'), null())]"
    },
    "redisDiagnosticSettings": {
      "condition": "[variables('enableMysqlDiagnosticSettings')]",
      "type": "Microsoft.Insights/diagnosticSettings",
      "apiVersion": "2021-05-01-preview",
      "scope": "[format('Microsoft.Cache/redis/{0}', parameters('serverName'))]",
      "name": "[format('{0}-diagnosticSettings', parameters('serverName'))]",
      "properties": {
        "eventHubAuthorizationRuleId": "[tryGet(tryGet(parameters('diagnosticSettingsProperties').diagnosticReceivers, 'eventHub'), 'eventHubAuthorizationRuleId')]",
        "eventHubName": "[tryGet(tryGet(parameters('diagnosticSettingsProperties').diagnosticReceivers, 'eventHub'), 'eventHubName')]",
        "logAnalyticsDestinationType": "[tryGet(parameters('diagnosticSettingsProperties').diagnosticReceivers, 'logAnalyticsDestinationType')]",
        "logs": "[tryGet(parameters('diagnosticSettingsProperties'), 'logs')]",
        "marketplacePartnerId": "[tryGet(parameters('diagnosticSettingsProperties').diagnosticReceivers, 'marketplacePartnerId')]",
        "metrics": "[tryGet(parameters('diagnosticSettingsProperties'), 'metrics')]",
        "serviceBusRuleId": "[tryGet(parameters('diagnosticSettingsProperties'), 'serviceBusRuleId')]",
        "storageAccountId": "[tryGet(parameters('diagnosticSettingsProperties').diagnosticReceivers, 'storageAccountId')]",
        "workspaceId": "[tryGet(parameters('diagnosticSettingsProperties').diagnosticReceivers, 'workspaceId')]"
      },
      "dependsOn": [
        "redisCache"
      ]
    },
    "redisFirewall": {
      "copy": {
        "name": "redisFirewall",
        "count": "[length(parameters('firewallRules'))]",
        "mode": "serial",
        "batchSize": 1
      },
      "condition": "[not(empty(parameters('firewallRules')))]",
      "type": "Microsoft.Cache/redis/firewallRules",
      "apiVersion": "2022-06-01",
      "name": "[format('{0}/{1}', parameters('serverName'), parameters('firewallRules')[copyIndex()].name)]",
      "properties": {
        "endIP": "[parameters('firewallRules')[copyIndex()].endIpAddress]",
        "startIP": "[parameters('firewallRules')[copyIndex()].startIpAddress]"
      },
      "dependsOn": [
        "redisCache"
      ]
    },
    "redisRbac": {
      "copy": {
        "name": "redisRbac",
        "count": "[length(parameters('roleAssignments'))]"
      },
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "[format('{0}-acr-rbac-{1}', parameters('serverName'), copyIndex())]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "description": "[if(contains(parameters('roleAssignments')[copyIndex()], 'description'), createObject('value', parameters('roleAssignments')[copyIndex()].description), createObject('value', ''))]",
          "principalIds": {
            "value": "[parameters('roleAssignments')[copyIndex()].principalIds]"
          },
          "roleDefinitionIdOrName": {
            "value": "[parameters('roleAssignments')[copyIndex()].roleDefinitionIdOrName]"
          },
          "principalType": "[if(contains(parameters('roleAssignments')[copyIndex()], 'principalType'), createObject('value', parameters('roleAssignments')[copyIndex()].principalType), createObject('value', ''))]",
          "resourceId": {
            "value": "[resourceId('Microsoft.Cache/redis', parameters('serverName'))]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "1.10-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "Symbolic name support in ARM is experimental, and should be enabled for testing purposes only. Do not enable this setting for any production usage, or you may be unexpectedly broken at any time!",
            "_generator": {
              "name": "bicep",
              "version": "0.19.5.34762",
              "templateHash": "13037231207085822473"
            }
          },
          "parameters": {
            "description": {
              "type": "string",
              "defaultValue": ""
            },
            "principalIds": {
              "type": "array"
            },
            "principalType": {
              "type": "string",
              "defaultValue": ""
            },
            "roleDefinitionIdOrName": {
              "type": "string"
            },
            "resourceId": {
              "type": "string"
            }
          },
          "variables": {
            "builtInRoleNames": {
              "Contributor": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b24988ac-6180-42a0-ab88-20f7382dd24c')]",
              "Log Analytics Contributor": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '92aaf0da-9dab-42b6-94a3-d43ce8d16293')]",
              "Log Analytics Reader": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '73c42c96-874c-492b-b04d-ab87d138a893')]",
              "Managed Application Contributor Role": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '641177b8-a67a-45b9-a033-47bc880bb21e')]",
              "Managed Application Operator Role": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'c7393b34-138c-406f-901b-d8cf2b17e6ae')]",
              "Managed Applications Reader": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b9331d33-8a36-4f8c-b097-4f54124fdb44')]",
              "Monitoring Contributor": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '749f88d5-cbae-40b8-bcfc-e573ddc772fa')]",
              "Monitoring Reader": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '43d0d8ad-25c7-4714-9337-8ba259a9fe05')]",
              "Owner": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '8e3af657-a8ff-443c-a75c-2fe8c4bcb635')]",
              "Reader": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'acdd72a7-3385-48ef-bd42-f606fba81ae7')]",
              "Redis Cache Contributor": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'e0f68234-74aa-48ed-b826-c38b57376e17')]",
              "Resource Policy Contributor": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '36243c78-bf99-498c-9df9-86d9f8d28608')]",
              "Role Based Access Control Administrator (Preview)": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'f58310d9-a9f6-439a-9e8d-f62e7b41a168')]",
              "User Access Administrator": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '18d7d88d-d35e-4fb5-a5c3-7773c20a72d9')]"
            }
          },
          "resources": {
            "redisCache": {
              "existing": true,
              "type": "Microsoft.Cache/redis",
              "apiVersion": "2021-06-01",
              "name": "[last(split(parameters('resourceId'), '/'))]"
            },
            "roleAssignment": {
              "copy": {
                "name": "roleAssignment",
                "count": "[length(parameters('principalIds'))]"
              },
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[format('Microsoft.Cache/redis/{0}', last(split(parameters('resourceId'), '/')))]",
              "name": "[guid(resourceId('Microsoft.Cache/redis', last(split(parameters('resourceId'), '/'))), parameters('principalIds')[copyIndex()], parameters('roleDefinitionIdOrName'))]",
              "properties": {
                "description": "[parameters('description')]",
                "roleDefinitionId": "[if(contains(variables('builtInRoleNames'), parameters('roleDefinitionIdOrName')), variables('builtInRoleNames')[parameters('roleDefinitionIdOrName')], parameters('roleDefinitionIdOrName'))]",
                "principalId": "[parameters('principalIds')[copyIndex()]]",
                "principalType": "[if(not(empty(parameters('principalType'))), parameters('principalType'), null())]"
              }
            }
          }
        }
      },
      "dependsOn": [
        "redisCache"
      ]
    },
    "redisCachePrivateEndpoint": {
      "condition": "[not(empty(variables('varPrivateEndpoints')))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "[format('{0}-redis-private-endpoints', uniqueString(deployment().name, parameters('location')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "privateEndpoints": {
            "value": "[variables('varPrivateEndpoints')]"
          },
          "tags": {
            "value": "[parameters('tags')]"
          },
          "manualApprovalEnabled": {
            "value": "[parameters('privateEndpointsApprovalEnabled')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "1.10-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "Symbolic name support in ARM is experimental, and should be enabled for testing purposes only. Do not enable this setting for any production usage, or you may be unexpectedly broken at any time!",
            "_generator": {
              "name": "bicep",
              "version": "0.19.5.34762",
              "templateHash": "8205690049017443365"
            }
          },
          "parameters": {
            "location": {
              "type": "string"
            },
            "tags": {
              "type": "object"
            },
            "manualApprovalEnabled": {
              "type": "bool"
            },
            "privateEndpoints": {
              "type": "array"
            }
          },
          "variables": {
            "copy": [
              {
                "name": "varPrivateEndpoints",
                "count": "[length(parameters('privateEndpoints'))]",
                "input": {
                  "name": "[parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].name]",
                  "privateLinkServiceId": "[parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].privateLinkServiceId]",
                  "groupIds": "[parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].groupIds]",
                  "subnetId": "[parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].subnetId]",
                  "privateDnsZones": "[if(contains(parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')], 'privateDnsZones'), parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].privateDnsZones, createArray())]",
                  "customNetworkInterfaceName": "[if(contains(parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')], 'customNetworkInterfaceName'), parameters('privateEndpoints')[copyIndex('varPrivateEndpoints')].customNetworkInterfaceName, null())]"
                }
              }
            ]
          },
          "resources": {
            "privateEndpoint": {
              "copy": {
                "name": "privateEndpoint",
                "count": "[length(variables('varPrivateEndpoints'))]",
                "mode": "serial",
                "batchSize": 1
              },
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2022-05-01",
              "name": "[format('{0}-{1}', variables('varPrivateEndpoints')[copyIndex()].name, uniqueString(variables('varPrivateEndpoints')[copyIndex()].name, variables('varPrivateEndpoints')[copyIndex()].subnetId, variables('varPrivateEndpoints')[copyIndex()].privateLinkServiceId))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "privateLinkServiceConnections": "[if(parameters('manualApprovalEnabled'), null(), createArray(createObject('name', variables('varPrivateEndpoints')[copyIndex()].name, 'properties', createObject('privateLinkServiceId', variables('varPrivateEndpoints')[copyIndex()].privateLinkServiceId, 'groupIds', if(not(empty(variables('varPrivateEndpoints')[copyIndex()].groupIds)), variables('varPrivateEndpoints')[copyIndex()].groupIds, null())))))]",
                "manualPrivateLinkServiceConnections": "[if(parameters('manualApprovalEnabled'), createArray(createObject('name', variables('varPrivateEndpoints')[copyIndex()].name, 'properties', createObject('privateLinkServiceId', variables('varPrivateEndpoints')[copyIndex()].privateLinkServiceId, 'groupIds', if(not(empty(variables('varPrivateEndpoints')[copyIndex()].groupIds)), variables('varPrivateEndpoints')[copyIndex()].groupIds, null())))), null())]",
                "subnet": {
                  "id": "[variables('varPrivateEndpoints')[copyIndex()].subnetId]"
                },
                "customNetworkInterfaceName": "[variables('varPrivateEndpoints')[copyIndex()].customNetworkInterfaceName]"
              }
            },
            "privateDnsZoneGroup": {
              "copy": {
                "name": "privateDnsZoneGroup",
                "count": "[length(variables('varPrivateEndpoints'))]",
                "mode": "serial",
                "batchSize": 1
              },
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2022-05-01",
              "name": "[format('{0}/{1}', format('{0}-{1}', variables('varPrivateEndpoints')[copyIndex()].name, uniqueString(variables('varPrivateEndpoints')[copyIndex()].name, variables('varPrivateEndpoints')[copyIndex()].subnetId, variables('varPrivateEndpoints')[copyIndex()].privateLinkServiceId)), 'default')]",
              "properties": {
                "copy": [
                  {
                    "name": "privateDnsZoneConfigs",
                    "count": "[length(variables('varPrivateEndpoints')[copyIndex()].privateDnsZones)]",
                    "input": {
                      "name": "[if(contains(variables('varPrivateEndpoints')[copyIndex()].privateDnsZones[copyIndex('privateDnsZoneConfigs')], 'name'), variables('varPrivateEndpoints')[copyIndex()].privateDnsZones[copyIndex('privateDnsZoneConfigs')].name, 'default')]",
                      "properties": {
                        "privateDnsZoneId": "[variables('varPrivateEndpoints')[copyIndex()].privateDnsZones[copyIndex('privateDnsZoneConfigs')].zoneId]"
                      }
                    }
                  }
                ]
              },
              "dependsOn": [
                "[format('privateEndpoint[{0}]', copyIndex())]"
              ]
            }
          }
        }
      },
      "dependsOn": [
        "redisCache"
      ]
    },
    "redisCachePatchSchedule": {
      "condition": "[not(empty(parameters('redisPatchSchedule')))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2022-09-01",
      "name": "[format('{0}-redis-patch-schedule', uniqueString(deployment().name, parameters('location')))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "redisCacheName": {
            "value": "[parameters('serverName')]"
          },
          "redisPatchSchedule": {
            "value": "[parameters('redisPatchSchedule')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "languageVersion": "1.10-experimental",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_EXPERIMENTAL_WARNING": "Symbolic name support in ARM is experimental, and should be enabled for testing purposes only. Do not enable this setting for any production usage, or you may be unexpectedly broken at any time!",
            "_generator": {
              "name": "bicep",
              "version": "0.19.5.34762",
              "templateHash": "7117239157057788955"
            }
          },
          "definitions": {
            "redisPatchScheduleType": {
              "type": "object",
              "properties": {
                "dayOfWeek": {
                  "type": "string",
                  "metadata": {
                    "description": "The day of the week when a cache can be patched. Possible values are Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday."
                  }
                },
                "startHourUtc": {
                  "type": "int",
                  "metadata": {
                    "description": "The start hour after which cache patching can start."
                  }
                },
                "maintenanceWindow": {
                  "type": "int",
                  "nullable": true,
                  "metadata": {
                    "description": "ISO8601 timespan specifying how much time cache patching can take."
                  }
                }
              }
            }
          },
          "parameters": {
            "redisCacheName": {
              "type": "string"
            },
            "redisPatchSchedule": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/redisPatchScheduleType"
              },
              "metadata": {
                "description": "The predefined schedule for patching redis server. The Patch Window lasts for 5 hours from the start_hour_utc.\nIf schedule is not specified, the update can happen at any time. See https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-administration#schedule-updates-faq\n"
              }
            }
          },
          "resources": {
            "redisCacheReference": {
              "existing": true,
              "type": "Microsoft.Cache/redis",
              "apiVersion": "2022-06-01",
              "name": "[parameters('redisCacheName')]"
            },
            "patchSchedule": {
              "condition": "[not(empty(parameters('redisPatchSchedule')))]",
              "type": "Microsoft.Cache/redis/patchSchedules",
              "apiVersion": "2022-06-01",
              "name": "[format('{0}/{1}', parameters('redisCacheName'), 'default')]",
              "properties": {
                "scheduleEntries": "[parameters('redisPatchSchedule')]"
              }
            }
          }
        }
      },
      "dependsOn": [
        "redisCache"
      ]
    }
  },
  "outputs": {
    "name": {
      "type": "string",
      "metadata": {
        "description": "The resource name."
      },
      "value": "[parameters('name')]"
    },
    "resourceId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID."
      },
      "value": "[resourceId('Microsoft.Cache/redis', parameters('serverName'))]"
    },
    "resourceGroupName": {
      "type": "string",
      "metadata": {
        "description": "The name of the resource group the Redis cache was created in."
      },
      "value": "[resourceGroup().name]"
    },
    "hostName": {
      "type": "string",
      "metadata": {
        "description": "Redis hostname."
      },
      "value": "[reference('redisCache').hostName]"
    },
    "sslPort": {
      "type": "int",
      "metadata": {
        "description": "Redis SSL port."
      },
      "value": "[reference('redisCache').sslPort]"
    },
    "location": {
      "type": "string",
      "metadata": {
        "description": "The location the resource was deployed into."
      },
      "value": "[reference('redisCache', '2022-06-01', 'full').location]"
    }
  }
}